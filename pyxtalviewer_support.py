#! /usr/bin/env python
#  -*- coding: utf-8 -*-
#
# Support module generated by PAGE version 4.17
# In conjunction with Tcl version 8.6
#    Oct 15, 2018 09:31:29 PM CEST  platform: Linux

import sys
import pyxtalmain_support
import matplotlib as mpl
import matplotlib.pyplot as plt
import matplotlib.backends.tkagg as tkagg
from matplotlib.backends.backend_agg import FigureCanvasAgg
#https://matplotlib.org/gallery/user_interfaces/embedding_in_tk_canvas_sgskip.html
from matplotlib.figure import Figure
from matplotlib.backends.backend_tkagg import (
        FigureCanvasTkAgg, NavigationToolbar2Tk)

try:
    from Tkinter import *
except ImportError:
    from tkinter import *

try:
    import ttk
    py3 = False
except ImportError:
    import tkinter.ttk as ttk
    py3 = True

def set_Tk_var():
    None
    #This function is a place holder, originally created by PAGE
    #It defined a zillion global Tk variables that were used for all
    #the widgets.  That functionality is now within the creation function.

    
def set_views_to_globals(viewer):
    viewer.whichImage.set(viewer.pmw.whichImage)
    viewer.invertImage.set(viewer.pmw.invertImage)
    viewer.showCircles.set(viewer.pmw.showCircles)
    viewer.showTriang.set(viewer.pmw.showTriang)
    viewer.showDefects.set(viewer.pmw.showDefects)
    viewer.showOrientation.set(viewer.pmw.showOrientation)
    

def changeVisibleAnnotations():
    print('pyxtalviewer_support.changeVisibleAnnotations')
    sys.stdout.flush()

def invertImageChange():
    print('pyxtalviewer_support.invertImageChange')
    sys.stdout.flush()

def showImageChange():
    print('pyxtalviewer_support.showImageChange')
    sys.stdout.flush()

def showStatsWin():
    print('pyxtalviewer_support.showStatsWin')
    sys.stdout.flush()

def xxx(p1):
    print('pyxtalviewer_support.xxx')
    print('p1 = {0}'.format(p1))
    sys.stdout.flush()

def load_images_and_locations(viewer):
    #Based on the input file type, this function reads the file.
    #If File is an image, it adds the location data.
    #If File is location data, it adds a fake "image" of spheres.
    #If File is assemblies, it calcultes both an image and location data.
    import matplotlib as mpl
    import matplotlib.pyplot as plt
    import numpy as np
    import trackpy as tp

    if viewer.pmw.inFileType.get() == "image":
        #use code from colloid group.
        print("finding particles")
        viewer.image = plt.imread(viewer.filename)
        viewer.imgshape = np.shape(viewer.image)
        
        #This gives dataframe with 8 columns. First two are y, x 
        full_locations = tp.locate(viewer.image[::-1], viewer.pmw.sphereSize[0])
        # note that the [::-1] notation above verses the array top-to-bottom.
        # Apparently the locate function reverses the y coordinate.
        viewer.locations = np.array(full_locations)[:,0:2]
        
    elif viewer.pmw.inFileType.get() == "particles":
        #read gsd file.
        None

def convert_pixel_to_axis(xy, viewer):
    xpix = xy[0]
    ypix = xy[1]
    canv_xmin = viewer.canvWidget.winfo_x() 
    canv_ymin = viewer.canvWidget.winfo_y()
    canv_w = viewer.canvWidget.winfo_width()
    canv_h = viewer.canvWidget.winfo_height()

    xlims = viewer.ax.get_xlim()
    ylims = viewer.ax.get_ylim()

    xratio = (xlims[1] - xlims[0]) / canv_w
    yratio = (ylims[1] - ylims[0]) / canv_h
    
    xcoor = xpix * xratio + xlims[0]
    ycoor = ylims[1] - ypix * xratio
    if isinstance(xy, tuple):
        return((xcoor, ycoor))
    if isinstance(xy, np.ndarray):
        return(np.array([xcoor, ycoor]))
    if isinstance(xy, list):
        return([xcoor, ycoor])

def zoom_OLD(event, viewer):
#    print('wheel event!')
#    print('           event = {0}'.format(event))
#    print("            ", viewer.filename)
    sys.stdout.flush()
    if str(event.type) == "ButtonPress": #Linux mouse wheel. Is there a better way?
        if event.num == 4:
            zoom_by = 1.25
        elif event.num == 5:
            zoom_by = 0.8
        else:
            print("error: zoom button not 4 or 5")
    else:
        print("error: probably a windows machine. Need to code mousewheel")
        return()
    mouse_xy = convert_pixel_to_axis((event.x, event.y), viewer)
    mouse_x = mouse_xy[0]
    mouse_y = mouse_xy[1]
#    print("          mouse location in pixels", (event.x, event.y))
#    print("          mouse location in axis coordinates", mouse_xy)

    old_xlims = viewer.ax.get_xlim()
    new_xmin = mouse_x - (mouse_x - old_xlims[0]) / zoom_by
    new_xmax = mouse_x + (old_xlims[1] - mouse_x) / zoom_by
    viewer.ax.set_xlim(new_xmin, new_xmax)

    old_ylims = viewer.ax.get_ylim()
    new_ymin = mouse_y - (mouse_y - old_ylims[0]) / zoom_by
    new_ymax = mouse_y + (old_ylims[1] - mouse_y) / zoom_by
    viewer.ax.set_ylim(new_ymin, new_ymax)

    viewer.imgCanvas.draw()

def zoom(event, viewer):
#    print('wheel event!')
#    print('           event = {0}'.format(event))
#    print("            ", viewer.filename)
    sys.stdout.flush()
    if str(event.type) == "ButtonPress": #Linux mouse wheel. Is there a better way?
        if event.num == 4:
            zoom_by = 1.25
        elif event.num == 5:
            zoom_by = 0.8
        else:
            print("error: zoom button not 4 or 5")
    else:
        print("error: probably a windows machine. Need to code mousewheel")
        return()
    mouse_xy = convert_pixel_to_axis((event.x, event.y), viewer)
    mouse_x = mouse_xy[0]
    mouse_y = mouse_xy[1]
#    print("          mouse location in pixels", (event.x, event.y))
#    print("          mouse location in axis coordinates", mouse_xy)

    old_xlims = viewer.ax.get_xlim()
    new_xmin = mouse_x - (mouse_x - old_xlims[0]) / zoom_by
    new_xmax = mouse_x + (old_xlims[1] - mouse_x) / zoom_by
    viewer.ax.set_xlim(new_xmin, new_xmax)

    old_ylims = viewer.ax.get_ylim()
    new_ymin = mouse_y - (mouse_y - old_ylims[0]) / zoom_by
    new_ymax = mouse_y + (old_ylims[1] - mouse_y) / zoom_by
    viewer.ax.set_ylim(new_ymin, new_ymax)

    viewer.imgCanvas.draw()


def translate(event,viewer):
    #translates (moves) image with mouse, when button held down.
    print('motion / button event!')
    print('           event = {0}'.format(event))
    sys.stdout.flush()
    xy_now = np.array([event.x, event.y])
    if str(event.type) in ("ButtonPress", "Motion") and viewer.mousebuttondown == False:
        viewer.mousebuttondown = True
        viewer.translate_home = xy_now
        return()
    elif str(event.type) == "ButtonRelease":
        viewer.mousebuttondown =False
        return()
    else: #must be a motion event with button down
        delta_pixels = ( convert_pixel_to_axis(xy_now, viewer) - 
                           convert_pixel_to_axis(viewer.translate_home, viewer) )
    

def key_event(p1,viewer):
    print('key event!')
    print('           p1 = {0}'.format(p1))
    print("            ", viewer.filename)
    sys.stdout.flush()
    


def setup_images(viewer):

    viewer.fig, viewer.ax = plt.subplots()
    x = range(300)
    viewer.ax.plot(x, x, '--', linewidth=5, color='firebrick',zorder=1)

    xsize,ysize = viewer.imgshape[0], viewer.imgshape[1]
    viewer.rawimg = viewer.ax.imshow(viewer.image, 
                              extent=[0, xsize, 0, ysize],
                              zorder=0,
                              cmap="gray"
                              )

    x2 = range(20,200,10)
    #self.dogimg = ax.imshow(thedog, extent=[0, 400, 0, 300],zorder=0.5)#, alpha=0.5) 
    
    circles = viewer.ax.scatter(viewer.locations[:,1],viewer.locations[:,0], 
                         color='green', zorder=2)
#    blueplot = viewer.ax.scatter(x2, x2, color='blue',zorder=2)
#    blueplot.set_visible(1)
    viewer.ax.axis('off')
#    viewer.ax.margins(x=0)
#    viewer.ax.margins(y=0)
    viewer.ax.set_xlim(0, xsize)
    viewer.ax.set_ylim(0, ysize)
    viewer.fig.subplots_adjust(left=0.0, right=1.0, top=1.0, bottom=0.0)

    #Replace current placeholder canvas with new canvas object that will
    #hold all of the pyplot figures.
    viewer.top.update() #possibly required for the winfo calls to work below.
    #Get current position of existing canvs:
    canv_relx = viewer.imgCanvas.winfo_x() / viewer.top.winfo_width()
    canv_rely = viewer.imgCanvas.winfo_y() / viewer.top.winfo_height()
    canv_relw = viewer.imgCanvas.winfo_width() / viewer.top.winfo_width()
    canv_relh = viewer.imgCanvas.winfo_height() / viewer.top.winfo_height()
    #Should I delete the old canvas? I think yes, below.
    viewer.imgCanvas.destroy()
    #Here's where we actually put the plot on the tk canvas:
    viewer.imgCanvas = FigureCanvasTkAgg(viewer.fig, master=viewer.top)
    viewer.canvWidget = viewer.imgCanvas.get_tk_widget()
    viewer.canvWidget.place(relx=canv_relx, 
                            rely=canv_rely,
                            relwidth=canv_relw,
                            relheight=canv_relh)

    #Now bind the canvas to mouse and keyboard events
    viewer.canvWidget.bind("<Button-4>", lambda e:zoom(e, viewer))
    viewer.canvWidget.bind("<Button-5>", lambda e:zoom(e, viewer))
#    viewer.canvWidget.bind('<B1-Motion>',lambda e:translate(e, viewer))
#    viewer.canvWidget.bind('<Button-1>', lambda e:translate(e, viewer))
#    viewer.canvWidget.bind('<ButtonRelease-1>', lambda e:translate(e, viewer))
    viewer.top.bind("<Key>", lambda e:key_event(e, viewer))



    

def init(top, viewer, *args, **kwargs):
    viewer.top = top
    viewer.pmw = args[0]
    viewer.filename = args[1]
    viewer.idx = args[2]
    set_views_to_globals(viewer)
    viewer.top.title("Pyxtal Viewer: "
                     + viewer.filename 
                     + " [" + str(viewer.idx) + "]")
    viewer.top.protocol("WM_DELETE_WINDOW", lambda: destroy_viewer(viewer))

    viewer.top.update()
    viewer.mousebuttondown = False    
    load_images_and_locations(viewer)
    setup_images(viewer)    
    viewer.top.update()    

def destroy_viewer(viewer):
    # Function which closes the window.
    viewer.pmw.viewers.remove(viewer) #remove from main list of viewers
    plt.close(viewer.fig) #keeps the plot from reappearing in the console.
    top = viewer.top
    top.destroy()

if __name__ == '__main__':
    #import pyxtalviewer
    #pyxtalviewer.vp_start_gui()
    #print("This file is not runnable as main.  Run Pyxtalmain.py instead.")
    import pyxtalmain
    pyxtalmain.vp_start_gui()

