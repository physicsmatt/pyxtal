#! /usr/bin/env python
#  -*- coding: utf-8 -*-
#
# Support module generated by PAGE version 4.17
# In conjunction with Tcl version 8.6
#    Oct 15, 2018 09:31:29 PM CEST  platform: Linux

import numpy as np
import sys
import pyxtalmain_support
import matplotlib as mpl
import matplotlib.pyplot as plt
import matplotlib.backends.tkagg as tkagg
from matplotlib.backends.backend_agg import FigureCanvasAgg
#https://matplotlib.org/gallery/user_interfaces/embedding_in_tk_canvas_sgskip.html
from matplotlib.figure import Figure
from matplotlib.backends.backend_tkagg import (
        FigureCanvasTkAgg, NavigationToolbar2Tk)

try:
    from Tkinter import *
except ImportError:
    from tkinter import *

try:
    import ttk
    py3 = False
except ImportError:
    import tkinter.ttk as ttk
    py3 = True

def set_Tk_var():
    None
    #This function is a place holder, originally created by PAGE
    #It defined a zillion global Tk variables that were used for all
    #the widgets.  That functionality is now within the creation function.

    
def set_views_to_globals(viewer):
    viewer.whichImage.set(viewer.pmw.whichImage)
    viewer.invertImage.set(viewer.pmw.invertImage)
    viewer.showCircles.set(viewer.pmw.showCircles)
    viewer.showTriang.set(viewer.pmw.showTriang)
    viewer.showDefects.set(viewer.pmw.showDefects)
    viewer.showOrientation.set(viewer.pmw.showOrientation)
    

def changeVisibleAnnotations():
    print('pyxtalviewer_support.changeVisibleAnnotations')
    sys.stdout.flush()

def invertImageChange():
    print('pyxtalviewer_support.invertImageChange')
    sys.stdout.flush()

def showImageChange():
    print('pyxtalviewer_support.showImageChange')
    sys.stdout.flush()

def showStatsWin():
    print('pyxtalviewer_support.showStatsWin')
    sys.stdout.flush()

#def xxx(p1):
#    print('pyxtalviewer_support.xxx')
#    print('p1 = {0}'.format(p1))
#    sys.stdout.flush()

def load_images_and_locations(viewer):
    #Based on the input file type, this function reads the file.
    #If File is an image, it adds the location data.
    #If File is location data, it adds a fake "image" of spheres.
    #If File is assemblies, it calcultes both an image and location data.
    import matplotlib as mpl
    import matplotlib.pyplot as plt
    import trackpy as tp

    if viewer.pmw.inFileType.get() == "image":
        #use code from colloid group.
        viewer.image = plt.imread(viewer.filename)
        viewer.imgshape = np.shape(viewer.image)
        
        #This gives dataframe with 8 columns. First two are y, x 
        full_locations = tp.locate(viewer.image[::-1], viewer.pmw.sphereSize[0])
        # note that the [::-1] notation above verses the array top-to-bottom.
        # Apparently the locate function reverses the y coordinate.
        viewer.locations = np.array(full_locations)[:,0:2]
        
    elif viewer.pmw.inFileType.get() == "particles":
        #read gsd file.
        None

def dev_to_data(xy, viewer):
    # This routine translates "device" coordinates (in pixels)
    # to "data coordinates", which are whatever is on the x and y axes.
    # Input xy can be either a tuple, list, or ndarray.
    # Output type matches input type.
    # It assumes value of pixel is same on both axes
    xpix = xy[0]
    ypix = xy[1]
    canv_xmin = viewer.canvWidget.winfo_x() 
    canv_ymin = viewer.canvWidget.winfo_y()
    canv_w = viewer.canvWidget.winfo_width()
    canv_h = viewer.canvWidget.winfo_height()

    xlims = viewer.ax.get_xlim()
    ylims = viewer.ax.get_ylim()

    ratio = (xlims[1] - xlims[0]) / canv_w
    
    xcoor = xpix * ratio + xlims[0]
    ycoor = ylims[1] - ypix * ratio
    if isinstance(xy, tuple):
        return((xcoor, ycoor))
    if isinstance(xy, np.ndarray):
        return(np.array([xcoor, ycoor]))
    if isinstance(xy, list):
        return([xcoor, ycoor])


def zoom(event, viewer):
    if str(event.type) == "ButtonPress": #Linux mouse wheel. Is there a better way?
        if event.num == 4:
            zoom_by = 1.25
        elif event.num == 5:
            zoom_by = 0.8
        else:
            print("error: zoom button not 4 or 5")
    else:
        print("error: probably a windows machine. Need to code mousewheel")
        return()
    mouse_xy = dev_to_data(np.array([event.x, event.y]), viewer)
    viewer.corners[0] = mouse_xy - (mouse_xy - viewer.corners[0]) / zoom_by
    viewer.corners[1] = mouse_xy + (viewer.corners[1] - mouse_xy) / zoom_by
    set_limits_to_corners(viewer)


def translate(event,v):
    #translates (moves) image with mouse, when button held down.
    xy_now = np.array([event.x, event.y])
    if str(event.type) in ("ButtonPress", "Motion") and v.mousebuttondown == False:
        v.mousebuttondown = True
        v.corners_home = v.corners.copy()
        v.xy_home = xy_now.copy()
        return()
    elif str(event.type) == "ButtonRelease":
        v.mousebuttondown = False
        return()
    else: #must be a motion event with button down
        delta_data = (dev_to_data(xy_now, v) - dev_to_data(v.xy_home, v) )
        v.corners = v.corners_home - delta_data
        set_limits_to_corners(v)
 
        
    

def key_event(p1,viewer):
    print('key event!')
    print('           p1 = {0}'.format(p1))
    print("            ", viewer.filename)
    sys.stdout.flush()
    

def set_limits_to_corners(viewer):
    viewer.ax.set_xlim(viewer.corners[0,0], viewer.corners[1,0])
    viewer.ax.set_ylim(viewer.corners[0,1], viewer.corners[1,1])
    viewer.imgCanvas.draw()
    

def setup_images(viewer):

    viewer.fig, viewer.ax = plt.subplots()

    xsize,ysize = viewer.imgshape[0], viewer.imgshape[1]
    viewer.corners = np.array([[0,0],[xsize,ysize]])

    viewer.rawimg = viewer.ax.imshow(viewer.image, 
                              extent=[0, xsize, 0, ysize],
                              zorder=0,
                              cmap="gray")

    
    circles = viewer.ax.scatter(viewer.locations[:,1],viewer.locations[:,0], 
                         color='green', zorder=2)
    viewer.ax.axis('off')
    viewer.fig.subplots_adjust(left=0.0, right=1.0, top=1.0, bottom=0.0)

    #Replace current placeholder canvas with new canvas object that will
    #hold all of the pyplot figures.
    viewer.top.update() #possibly required for the winfo calls to work below.
    #Get current position of existing canvs:
    canv_relx = viewer.imgCanvas.winfo_x() / viewer.top.winfo_width()
    canv_rely = viewer.imgCanvas.winfo_y() / viewer.top.winfo_height()
    canv_relw = viewer.imgCanvas.winfo_width() / viewer.top.winfo_width()
    canv_relh = viewer.imgCanvas.winfo_height() / viewer.top.winfo_height()
    #Should I delete the old canvas? I think yes, below.
    viewer.imgCanvas.destroy()
    #Here's where we actually put the plot on the tk canvas:
    viewer.imgCanvas = FigureCanvasTkAgg(viewer.fig, master=viewer.top)
    viewer.canvWidget = viewer.imgCanvas.get_tk_widget()
    viewer.canvWidget.place(relx=canv_relx, 
                            rely=canv_rely,
                            relwidth=canv_relw,
                            relheight=canv_relh)
    set_limits_to_corners(viewer)

    #Now bind the canvas to mouse and keyboard events
    viewer.canvWidget.bind("<Button-4>", lambda e:zoom(e, viewer))
    viewer.canvWidget.bind("<Button-5>", lambda e:zoom(e, viewer))
    viewer.canvWidget.bind('<B1-Motion>',lambda e:translate(e, viewer))
    viewer.canvWidget.bind('<Button-1>', lambda e:translate(e, viewer))
    viewer.canvWidget.bind('<ButtonRelease-1>', lambda e:translate(e, viewer))
    viewer.top.bind("<Key>", lambda e:key_event(e, viewer))



    

def init(top, viewer, *args, **kwargs):
    viewer.top = top
    viewer.pmw = args[0]
    viewer.filename = args[1]
    viewer.idx = args[2]
    set_views_to_globals(viewer)
    viewer.top.title("Pyxtal Viewer: "
                     + viewer.filename 
                     + " [" + str(viewer.idx) + "]")
    viewer.top.protocol("WM_DELETE_WINDOW", lambda: destroy_viewer(viewer))

    viewer.top.update()
    viewer.mousebuttondown = False    
    load_images_and_locations(viewer)
    setup_images(viewer)    
    viewer.top.update()    

def destroy_viewer(viewer):
    # Function which closes the window.
    viewer.pmw.viewers.remove(viewer) #remove from main list of viewers
    plt.close(viewer.fig) #keeps the plot from reappearing in the console.
    top = viewer.top
    top.destroy()

if __name__ == '__main__':
    #import pyxtalviewer
    #pyxtalviewer.vp_start_gui()
    #print("This file is not runnable as main.  Run Pyxtalmain.py instead.")
    import pyxtalmain
    pyxtalmain.vp_start_gui()

