#! /usr/bin/env python
#  -*- coding: utf-8 -*-
#
# Support module generated by PAGE version 4.17
# In conjunction with Tcl version 8.6
#    Oct 15, 2018 09:31:29 PM CEST  platform: Linux

import numpy as np
import sys
import pyxtal_support
import pyxtal_image_processing as pimg
import matplotlib.pyplot as plt
#import matplotlib.backends.tkagg as tkagg
#from matplotlib.backends.backend_agg import FigureCanvasAgg
#https://matplotlib.org/gallery/user_interfaces/embedding_in_tk_canvas_sgskip.html
#from matplotlib.figure import Figure
from matplotlib.backends.backend_tkagg import (FigureCanvasTkAgg)
#from matplotlib.backends.backend_tkagg import NavigationToolbar2Tk

try:
    from Tkinter import *
except ImportError:
    from tkinter import *

try:
    import ttk
    py3 = False
except ImportError:
    import tkinter.ttk as ttk
    py3 = True

def set_Tk_var():
    None
    #This function is a place holder, originally created by PAGE
    #It defined a zillion global Tk variables that were used for all
    #the widgets.  That functionality is now within the creation function.

    
def set_views_to_globals(viewer):
    viewer.whichImage.set(viewer.pmw.whichImage)
    viewer.invertImage.set(viewer.pmw.invertImage)
    viewer.showCircles.set(viewer.pmw.showCircles)
    viewer.showTriang.set(viewer.pmw.showTriang)
    viewer.showDefects.set(viewer.pmw.showDefects)
    viewer.showOrientation.set(viewer.pmw.showOrientation)
    
def changeInvert(viewer):
    invert = viewer.invertImage.get()
    if invert:
        viewer.plt_rawimg.set_data(viewer.inv_image)
    else:
        viewer.plt_rawimg.set_data(viewer.image)
    viewer.imgCanvas.draw()

def changeVisibleAnnotations(viewer):
    imagetype = viewer.whichImage.get()
    if imagetype == "raw":
        viewer.plt_rawimg.set_visible(True)
    if imagetype == "none":
        viewer.plt_rawimg.set_visible(False)
    viewer.plt_circles.set_visible(viewer.showCircles.get())
    viewer.plt_triang.set_visible(viewer.showTriang.get())
    viewer.plt_angleimg.set_visible(viewer.showOrientation.get())
    viewer.plt_disc.set_visible(viewer.showDefects.get())
    viewer.imgCanvas.draw()
#The variables below still need to be implemented and eventually included
#in the list above:
#        self.showTraject = BooleanVar()
#        self.showStats = BooleanVar()
    

def showStatsWin():
    print('pyxtalviewer_support.showStatsWin')
    sys.stdout.flush()


def load_images_and_locations(viewer):
    #Based on the input file type, this function reads the file.
    #If File is an image, it adds the location data.
    #If File is location data, it adds a fake "image" of spheres.
    #If File is assemblies, it calcultes both an image and location data.

#    import trackpy as tp
    import gsd.hoomd

    if viewer.pmw.inFileType.get() == "image":
        #use code from colloid group.
        viewer.image = plt.imread(viewer.filename)
#below I can clip the image to something smaller, just for debugging purposes
#        viewer.image = viewer.image[0:600,0:900]
        viewer.imgshape = np.flip(np.shape(viewer.image))  #Note that order now [x, y]
        
        #This gives dataframe with 8 columns. First two columns are y, x 
        full_locations = tp.locate(viewer.image[::-1], viewer.pmw.sphereSize[0])
        # note that the [::-1] notation above verses the array top-to-bottom.
        # Apparently the locate function reverses the y coordinate.
        viewer.locations = np.array(full_locations)[:,0:2]
        # It also puts y before x, so flip again:
        viewer.locations = np.flip(viewer.locations, axis = 1)
        
    elif viewer.pmw.inFileType.get() == "particles":
        #read gsd file
        s = gsd.hoomd.open(name=viewer.filename, mode='rb')
        fn = viewer.framenum  #this value was passed in from pmw
        if fn > len(s):
            print("ERROR: frame number out of range")
        viewer.locations = s[fn].particles.position[:,0:2].copy() #do I need a copy here?

        #The hoomd box seems to be always centered on 0,0;
        #I shift the particle locations so 0,0 is the lower left corner.
        boxsize = s[fn].configuration.box[0:2]  #z-component not used. assuming x,y.
        viewer.locations += boxsize / 2

        #I also scale all locations by an arbitrary scale factor.
        #Each new unit corresponds to a pixel in the displayed orientation image.
        viewer.locations *= 10
        boxsize = np.ceil(boxsize) * 10
#Eventually, I should get the sphere size from gsd particle diameter
        viewer.pmw.sphereSize[0] = 1 * 10
        viewer.imgshape = np.array([int(boxsize[0]),int(boxsize[1])])

    else: #must be a gsd assembly
        None #not yet implemented

def dev_to_data(xy, viewer):
    # This routine translates "device" coordinates (in pixels)
    # to "data coordinates", which are whatever is on the x and y axes.
    # Input xy can be either a tuple, list, or ndarray.
    # Output type matches input type.
    # It assumes value of pixel is same on both axes
    xpix = xy[0]
    ypix = xy[1]
    canv_xmin = viewer.canvWidget.winfo_x() 
    canv_ymin = viewer.canvWidget.winfo_y()
    canv_w = viewer.canvWidget.winfo_width()
    canv_h = viewer.canvWidget.winfo_height()

    xlims = viewer.ax.get_xlim()
    ylims = viewer.ax.get_ylim()

    ratio = (xlims[1] - xlims[0]) / canv_w
    
    xcoor = xpix * ratio + xlims[0]
    ycoor = ylims[1] - ypix * ratio
    if isinstance(xy, tuple):
        return((xcoor, ycoor))
    if isinstance(xy, np.ndarray):
        return(np.array([xcoor, ycoor]))
    if isinstance(xy, list):
        return([xcoor, ycoor])


def zoom(event, viewer):
    if str(event.type) == "ButtonPress": #Linux mouse wheel. Is there a better way?
        if event.num == 4:
            zoom_by = 1.25
        elif event.num == 5:
            zoom_by = 0.8
        else:
            print("error: zoom button not 4 or 5")
    else:
        print("error: probably a windows machine. Need to code mousewheel")
        return()
    # To zoom, first change the axes:
    viewer.zoom *= zoom_by
    mouse_xy = dev_to_data(np.array([event.x, event.y]), viewer)
    viewer.corners[0] = mouse_xy - (mouse_xy - viewer.corners[0]) / zoom_by
    viewer.corners[1] = mouse_xy + (viewer.corners[1] - mouse_xy) / zoom_by
    set_limits_to_corners(viewer)
    #Also, scale various line thicknesses accordingly
    zoom_linewidths(viewer)
    viewer.imgCanvas.draw()

    
def zoom_linewidths(v): 
    #I'll suppose for now I want the thickness to be one image pixel
    #For now, I'm just going to make a starting guess and scale it.
    #On second thought that fails for small images with big spheres.
    lw = 1 * int(np.ceil(v.zoom))

    #Instead, let's make it always be sphereSize/10.  But how do I get
    #a sphere size in points?
    lw = convert_data_to_points(v.pmw.sphereSize[0]/10, v)
    v.plt_circles.set_linewidth(lw)
    v.plt_triang.set_linewidth(lw)
    #v.imgCanvas.draw()
   
    
def convert_data_to_points(data, viewer):
    #converts data coordinates to printers' "points", used for linewidths.
    length = viewer.fig.bbox_inches.width * viewer.ax.get_position().width
    value_range = np.diff(viewer.ax.get_xlim())
    # Convert length of axis to points
    length *= 72
    # Return data_coords converted to points
    return (data * (length / value_range))



def translate(event,v):
    #translates (moves) image with mouse, when button held down.
    #Also handles double clicking.
    import datetime
    
    time_now = datetime.datetime.now()
    xy_now = np.array([event.x, event.y])
    if str(event.type) in ("ButtonPress", "Motion") and v.mousebuttondown == False:
        #Button has apparently been clicked.
        
        #First, detect if it was a double click.  If so, recenter image.
        timenow = datetime.datetime.now()
        if v.prev_button_time != None:
            ms_elapsed = (timenow - v.prev_button_time).total_seconds()
            if ms_elapsed < 0.250:
                #Yes, this was a double click.
                v.zoom = 1.0
                v.corners = np.array([[0,0],v.imgshape])
                set_limits_to_corners(v)
                zoom_linewidths(v)
                v.imgCanvas.draw()
        v.prev_button_time = timenow

        #Now set "home position" relative to which we move the image on motion.
        v.mousebuttondown = True
        v.corners_home = v.corners.copy()
        v.xy_home = xy_now.copy()
        return()
    elif str(event.type) == "ButtonRelease":
        v.mousebuttondown = False
        return()
    else: #must be a motion event with button down
        delta_data = (dev_to_data(xy_now, v) - dev_to_data(v.xy_home, v) )
        v.corners = v.corners_home - delta_data
        set_limits_to_corners(v)
        v.imgCanvas.draw()
 

def key_event(event,viewer):
    # This function parses and handles keyboard events.
    # So far, the only keyboard keys enabled are the left and right arrows,
    # used for flipping through the viewer windows.
    if event.keysym in ("Left", "Right"): #right or left arrows
        thisidx = viewer.idx
        if event.keysym == ("Left"):
            targetidx = thisidx - 1
        else:
            targetidx = thisidx + 1
            if targetidx >= len(viewer.pmw.viewers):
                targetidx = 0
        viewer.pmw.viewers[targetidx].top.lift()
        viewer.pmw.viewers[targetidx].top.focus_force()
    

def set_limits_to_corners(viewer):
    viewer.ax.set_xlim(viewer.corners[0,0], viewer.corners[1,0])
    viewer.ax.set_ylim(viewer.corners[0,1], viewer.corners[1,1])
    #viewer.imgCanvas.draw()
    

def setup_canvas_and_axes(viewer):
    viewer.fig, viewer.ax = plt.subplots()
    viewer.ax.axis('off')
    viewer.fig.subplots_adjust(left=0.0, right=1.0, top=1.0, bottom=0.0)

    #Replace current placeholder canvas with new canvas object that will
    #hold all of the pyplot figures.
    viewer.top.update() #possibly required for the winfo calls to work below.
    #Get current position of existing canvs:
    canv_relx = viewer.imgCanvas.winfo_x() / viewer.top.winfo_width()
    canv_rely = viewer.imgCanvas.winfo_y() / viewer.top.winfo_height()
    canv_relw = viewer.imgCanvas.winfo_width() / viewer.top.winfo_width()
    canv_relh = viewer.imgCanvas.winfo_height() / viewer.top.winfo_height()
    #Should I delete the old canvas? I think yes, below.
    viewer.imgCanvas.destroy()
    #Here's where we actually put the plot on the tk canvas:
    viewer.imgCanvas = FigureCanvasTkAgg(viewer.fig, master=viewer.top)
    viewer.canvWidget = viewer.imgCanvas.get_tk_widget()
    viewer.canvWidget.place(relx=canv_relx, 
                            rely=canv_rely,
                            relwidth=canv_relw,
                            relheight=canv_relh)

    #Now bind the canvas to mouse and keyboard events
    viewer.canvWidget.bind("<Button-4>", lambda e:zoom(e, viewer))
    viewer.canvWidget.bind("<Button-5>", lambda e:zoom(e, viewer))
    viewer.canvWidget.bind('<B1-Motion>',lambda e:translate(e, viewer))
    viewer.canvWidget.bind('<Button-1>', lambda e:translate(e, viewer))
    viewer.canvWidget.bind('<ButtonRelease-1>', lambda e:translate(e, viewer))
    viewer.canvWidget.bind('<Double-Button-1>', lambda e:translate(e, viewer))
    viewer.top.bind("<Key>", lambda e:key_event(e, viewer))

    #Add some other housekeeping parts to the viewer, to keep track of
    #zooming and translation
    viewer.corners = np.array([ [0,0], viewer.imgshape ])
    set_limits_to_corners(viewer)
    viewer.prev_button_time = None
    viewer.zoom = 1.00


def init(top, viewer, *args, **kwargs):
    viewer.top = top
    viewer.pmw = args[0]
    viewer.filename = args[1]
    viewer.idx = args[2]
    viewer.framenum = args[3]
    set_views_to_globals(viewer)
    viewer.top.title("Pyxtal Viewer "
                     + "[" + str(viewer.idx) + "]: "
                     + "        " + viewer.filename + "          "
                     + "(frame: " + str(viewer.framenum) + ")"  )
    viewer.top.protocol("WM_DELETE_WINDOW", lambda: destroy_viewer(viewer))

    viewer.top.update()
    viewer.mousebuttondown = False    
    load_images_and_locations(viewer)
    setup_canvas_and_axes(viewer)
    pimg.do_raw_image(viewer)
#    pimg.do_inverted_images(viewer)
    pimg.do_circle_plot(viewer)
    pimg.do_triangulation(viewer)
    pimg.do_disclinations(viewer)
    pimg.do_angle_field(viewer)
    changeVisibleAnnotations(viewer)
    zoom_linewidths(viewer)
    #print(dir(viewer))
    #print(dir(viewer.tri))

def destroy_viewer(viewer):
    # Function which closes the individual viewer.
    viewer.pmw.viewers.remove(viewer) #remove from main list of viewers
    plt.close(viewer.fig) #keeps the plot from reappearing in the console.
    top = viewer.top
    top.destroy()

if __name__ == '__main__':
    #import pyxtalviewer
    #pyxtalviewer.vp_start_gui()
    #print("This file is not runnable as main.  Run pyxtal.py instead.")
    import pyxtal
    pyxtal.vp_start_gui()

